`include "tiny16.vh"
module tiny16
#(parameter
  // 8k 8 bit words RAM
  RAM_BITS = 13
)
(
    input wire clk,
    input wire nreset,
    output reg hlt = 0,
    output reg wfi = 0,
    output wire [15:0] address,
    input wire [15:0] data_in,
    output wire [15:0] data_out,
    output reg mem_valid = 0,
    output wire nwr,
    input wire mem_ready,
    input wire interrupt,
    output reg in_interrupt = 0
);
    localparam MICROCODE_SIZE = 512;
    localparam MICROCODE_LENGTH = 32;

    localparam SP = 127;

    localparam STAGE_WIDTH = 6;

    localparam ALU_OP_ADC  = 0;
    localparam ALU_OP_ADD  = 1;
    localparam ALU_OP_SBC  = 2;
    localparam ALU_OP_SUB  = 3;
    localparam ALU_OP_CMP  = 4;
    localparam ALU_OP_AND  = 5;
    localparam ALU_OP_TEST = 6;
    localparam ALU_OP_OR   = 7;
    localparam ALU_OP_XOR  = 8;
    localparam ALU_OP_SHL  = 9;
    localparam ALU_OP_SHR  = 10;
    localparam ALU_OP_ROL  = 11;
    localparam ALU_OP_ROR  = 12;
    localparam ALU_OP_MUL  = 15;

    reg [STAGE_WIDTH - 1:0] stage;
    reg stage_reset;
    reg start;

    reg [MICROCODE_LENGTH-1:0] microcode [0:MICROCODE_SIZE-1];
    reg [MICROCODE_LENGTH-1:0] current_microcode;

    reg [15:0] registers [0:127];
    reg [15:0] reg1_data, reg2_data;
    reg [15:0] pc, saved_pc, sp;
    reg registers_wr;

    wire go;

    reg [7:0] ram [0:(1<<RAM_BITS)-1];
    reg ram_wr;
    reg [7:0] src, dst;
    reg [RAM_BITS - 1:0] src_addr, dst_addr;

    reg c;
    wire z, n;

    wire [2:0] condition, condition_temp;
    wire condition_neg, condition_pass;

    reg interrupt_request;
    wire interrupt_enter;

    reg [3:0] alu_op;
    reg [15:0] acc;
    reg [7:0] op1, op2;
    wire [15:0] op12;

    initial begin
        $readmemh("microcode.hex", microcode);
        $readmemh("asm/code.hex", ram);
    end

    assign z = acc == 0;
    assign n = acc[15];

    assign condition = alu_op[2:0];
    assign condition_neg = alu_op[3];

    assign condition_temp = condition & {c, z, n};
    assign condition_pass = (condition_temp[0] | condition_temp[1] | condition_temp[2]) ^ condition_neg;

    assign interrupt_enter = interrupt_request & !in_interrupt;

    assign go = start & !hlt;

    assign op12 = {op1, op2};

    assign op = current_microcode[4:0];
    assign stage_reset4 = current_microcode[5];
    assign pc_source4 = current_microcode[9:8];
    assign stage_reset8 = current_microcode[10];
    assign registers_wr8 = current_microcode[11];
    assign registers_wr_addr8 = current_microcode[12];
    assign pc_source8 = current_microcode[14:13];
    assign stage_reset16 = current_microcode[15];
    assign registers_wr16 = current_microcode[16];

    assign hlt_ = op == 0;
    assign wfi_ = op == 1;

    always @(negedge clk) begin
        if (!nreset) begin
            stage <= 1;
            start <= 0;
        end
        else if (stage_reset)
            stage <= 1;
        else begin
            if (stage[STAGE_WIDTH-1])
                start <= 1;
            stage <= {stage[STAGE_WIDTH - 2:0], stage[STAGE_WIDTH - 1]};
        end
    end

    always @(negedge clk) begin
        interrupt_request <= nreset ? interrupt : 0;
    end

    always @(negedge clk) begin
        if (ram_wr)
            ram[dst_addr] <= dst;
        else
            src <= ram[src_addr];
    end

    always @(posedge clk) begin
        if (registers_wr)
            registers[registers_wr_addr] <= acc;
        else begin
            sp <= registers[SP];
            registers_data2 <= registers_data;
            registers_data <= registers[src[6:0]];
        end
    end

    always @(negedge clk) begin
        current_microcode <= microcode[{current_instruction[7:2], stage}];
    end

    always @(posedge clk) begin
        if (!nreset) begin
            hlt <= 0;
            stage_reset <= 0;
            mem_valid <= 0;
            pc <= 0;
            ram_wr <= 0;
            registers_wr <= 0;
            start <= 0;
            current_instruction <= NOP;
            src_addr <= 0;
        end
        else if (go) begin
            if (stage == 0)
                    registers_wr <= 0;
                    stage_reset <= (mem_valid & !mem_ready) | (wfi & !interrupt_request) | interrupt_enter;
                    if (interrupt_request)
                        wfi <= 0;
                    if (interrupt_enter) begin
                        src_addr <= 3;
                        pc <= 3;
                        saved_pc <= pc;
                        in_interrupt <= 1;
                    end
                    else begin
                        current_instruction <= src;
                        pc <= pc + 1;
                        src_addr <= src_addr + 1;
                    end
                    if (mem_ready)
                        mem_valid <= 0;
                end
                2: begin
                    pc <= pc + 1;
                    src_addr <= src_addr + 1;
                end
                4: begin
                    stage_reset <= stage_reset4;
                    hlt <= hlt_;
                    wfi <= wfi_;
                    op1 <= src;
                    case (pc_source4)
                        PC_SOURCE_NEXT: begin
                            pc <= pc + 1;
                            src_addr <= src_addr + 1;
                        end
                        PC_SOURCE_SAVED: pc <= saved_pc; //reti
                        PC_SOURCE_SP: begin // pop/ret
                            src_addr <= sp;
                            acc <= sp + 1;
                            registers_wr_addr <= SP;
                        end
                    endcase
                end
                8: begin
                    stage_reset <= stage_reset8;
                    op2 <= src;
                    registers_wr <= registers_wr8;
                    registers_wr_addr <= registers_wr_addr8 ? op1[6:0] : src[6:0];
                    case (pc_source8)
                        PC_SOURCE_NEXT: begin
                            pc <= pc + 1;
                            src_addr <= src_addr + 1;
                        end
                        PC_SOURCE_BRANCH: if (condition_pass) pc <= op12;
                        PC_SOURCE_IMMEDIATE: pc <= op12;
                        PC_SOURCE_SP: begin
                            src_addr <= sp - 2; // push, call
                            sp <= sp - 2;
                        end
                    endcase
                    case (op)
                        OP_INC: acc <= reg1_data + 1;
                        OP_DEC: acc <= reg1_data - 1;
                        OP_CLR: acc <= 0;
                        OP_SET: acc <= 16'hFFFF;
                        OP_NOT: acc <= ~reg1_data;
                        OP_NEG: acc <= -reg1_data;
                        OP_SHL: {c, acc} <= reg1_data << 1;
                        OP_SHR: {acc, c} <= reg1_data >> 1;
                        OP_ROL: {c, acc} <= {reg1_data, c} << 1;
                        OP_ROR: {acc, c} <= {c, reg1_data} >> 1;
                        OP_MOV: acc <= reg1_data;
                    endcase
                end
                16: begin
                    data <= src;
                    stage_reset <= stage_reset16;
                    registers_wr <= registers_wr16;
                    case (op)
                        OP_ADD, OP_ADC: {acc, c} <= reg1_data + reg2_data + (adc ? c : 0);
                        OP_SUB, OP_SBC, OP_CMP: {acc, c} <= reg1_data - reg2_data - (sbc ? c : 0);
                        OP_AND, OP_TEST: acc <= reg1_data & reg2_data;
                        OP_OR: acc <= reg1_data | reg2_data;
                        OP_XOR: acc <= reg1_data ^ reg2_data;
                    endcase
                end
                32: begin
                end
            endcase
        end
    end

endmodule



            stage_reset <= ((stage == 0) & ((mem_valid & !mem_ready) | (wfi & !interrupt_request) | interrupt_enter)) | stage_reset_;
            if (wfi_ | interrupt_enter)
                wfi <= !interrupt_enter;
            hlt <= hlt_;
            if (!wfi_) begin
                case (src_addr_source)
                    SRC_ADDR_SOURCE_NEXT: src_addr <= interrupt_enter ? 3 : src_addr + 1;
                    SRC_ADDR_SOURCE_SAVED: src_addr <= saved_pc[RAM_BITS-1:0];
                    SRC_ADDR_SOURCE_IMMEDIATE: src_addr <= op12[RAM_BITS-1:0];
                    default: begin end
                endcase
                case (pc_source)
                    PC_SOURCE_NEXT: pc <= interrupt_enter ? 3 : pc + 1;
                    PC_SOURCE_SAVED: pc <= saved_pc;
                    PC_SOURCE_IMMEDIATE: pc <= op12;
                    default: begin end
                endcase
                if (stage == 0)
                    current_instruction <= src;
            end
            op2 <= op1;
            op1 <= src;
            if (pc_source == PC_SOURCE_SAVED || interrupt_enter)
                in_interrupt <= interrupt_enter;
            if (interrupt_enter)
                saved_pc <= pc;
            if (mem_ready)
                mem_valid <= 0;
            if (alu_op != 0)
                registers_wr_addr <= src[6:0];
            case (alu_op)
               ALU_OP_MOV: acc<= registers_data2;
               ALU_OP_CLR: acc<= 0;
               ALU_OP_SET: acc<= 16'hFFFF;
               ALU_OP_INC: acc <= registers_data + 1;
               ALU_OP_DEC: acc <= registers_data - 1;
               ALU_OP_NOT: acc <= ~registers_data;
               ALU_OP_NEG: acc <= -registers_data;
               default: begin end
            endcase
        end
